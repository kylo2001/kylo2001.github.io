---
layout: post
title:  "DP"
date:   2018-08-13 11:57:00
categories: algorithm
tags: featured
image: /assets/article_images/2014-08-29-welcome-to-jekyll/desktop.JPG
comments: true

---



## DP (다이나믹 프로그래밍)



이 챕터에서는 분할 정복, 탐욕 방법 같은 다른 기술들을 사용하여 최적의 해결책을 찾지 못하는 문제들을 풀어 볼 것이다. 동적 계획법은 간단한 기술이지만 완전히 익히는 것은 어렵다. DP문제를 익힐 수 있는 쉬운 방법은 가능한 많은 문제들을 풀어보는 것이다. 



**동적 계획법의 전략?**

동적 계획법은 메모이제이션과 함께 동작한다. 분할 정복과 동적 계획법의 큰 차이점은 분할 정복은 하위 문제들이 독립적이지만 DP는 하위 문제들 간의 중첩이 일어납니다. 

동적 계획법은 많은 문제들에 대해 메모이제이션을 사용하여(이미 해결한 하위 문제들을 테이블에 보관한다.) 지수적 복잡도(O(2^n), O(3^n) 등 )를 다항적 복잡도(O(n^2), O(n^3) 등)로 줄입니다. DP의 핵심적인 구성 요소들은 다음과 같다.

* 재귀(Recursion) : 하위 문제들을 재귀적으로 처리한다.

* 메모이제이션(Memoization) : 이미 계산된 값들을 테이블에 저장한다(메모이제이션은 캐싱을 의미한다).

  동적 계획법(Dynamic Programming) = 재귀(Recursion) + 메모이제이션(Memoization)



**동적 계획법 전략의 특성**

동적 계획법의 아래와 같은 두 가지 특징으로 주어진 문제를 해결할 수 있는지 여부를 알 수 있다.

* 최적의 하부 구조(Optimal substructure) : 문제에 대한 최적의 해결방법은 하부 문제들에 대한 최적의 해결책을 포함한다.
* 하위 문제들의 중첩(Overlapping subproblems) : 문제에 대한 재귀적 해결 방법은 빈번하게 반복되는 적은 수의 서로 다른 하위 문제들을 가진다.



**동적 계획법으로 모든 문제를 풀 수 있을까?**

탐욕 기술, 분할 정복 기술과 동일하게 DP로 모든 문제를 풀 수는 없다. 어떤 알고리즘적 기술(탐욕, 분할 정복 그리고 동적 계획법)로도 풀리지 않는 문제들이 있다.

동적 계획법과 직접적인 재귀의 차이점은 재귀 호출의 메모이제이션이다. 만일 하위 문제들이 독립적이고 반복이 없다면 메모이제이션은 도움이 되지 않는다. 따라서 동적 계획법은 모든 문제들의 해결책이 아니다.



**동적 계획법 접근 방법들**

DP문제를 풀기 위해 기본적으로 아래 두 가지 접근법이 있다.

* Bottom-Up 동적 계획법
* Top-Down 동적 계획법



**Bottom-Up 동적 계획법**

문제에 대한 해법이 하위 문제들을 가지고 재귀적으로 공식화되면 문제를 bottom-up 방식으로 제공식화할 수 있다. 먼저 하위 문제들을 풀고 나서 이 해답들을 더 큰 하위 문제에 대한 해법을 조립하고 도출하기 위해 사용한다. 이 방법은 일반적으로 작은 하위 문제의 솔루션을 사용하여 점점 더 큰 상위 문제들의 해답을 반복적으로 만들어 표에 정리해 완성한다.



**Top-Down 동적 계획법**

이 방법은 문제의 재귀식에서 바로 도출된다. 문제의 해답이 하위 문제들의 해답을 재귀적으로 사용하여 표현하고 하위 문제들이 서로 중첩된다면 하위 문제들의 해답들을 한 번씩 테이블에 저장 혹은 메모이즈(Memoize)한다. 새로운 하위 문제들을 풀어야 할 때 먼저 테이블에 이미 같은 하위 문제의 해답이 있는지 확인한다. 존재하면 이미 계산된 값을 바로 사용하고 그렇지 않으면 해당 하위 문제의 해답을 테이블에 저장한다.



**Bottom-Up VS Top-Down 프로그래밍**

Bottom-Up 프로그래밍에서 프로그래머는 계산할 값들과 계산 순서를 생각해야 합니다. 이 경우 필요한 모든 하위 문제들은 먼저 해결되어 더 큰 하위 문제의 해결책을 구축하는데 사용된다.

Top-Down 프로그래밍에서 사용한 원래 코드의 재귀 구조는 유지되지만 불필요한 재계산을 피할 수 있다. 문제를 하위 문제로 분할한 후 이러한 하위 문제들을 풀고, 다시 풀어야 할 더 큰 하위 문제를 풀때 필요한 만큼 푼 결과들을 저장한다.



많은 사람들이 알고 있는 피보나치 수열을 예로 좀 더 이해를 해보자.



피보나치 수열이란 현재 수는 이전 두 수 의 합인 수를 말한다. 다음과 같이 정의된다.

```
fib(n) = 0, n = 0일때
       = 1, for n = 1 일때
       = fib(n - 1) + fib(n - 2). for n > 1일때
```



이를 재귀적으로 함수를 구현해보면 아래와 같다.

```
int recursiveFibonacci(int n) {
    if(n == 0) 
        return 0;
    if(n == 1)
    	return 1;
    return recursiveFibonacci(n - 1) + recursiveFibonacci(n - 2);
}
```

![](https://user-images.githubusercontent.com/20294786/44010184-e8d90104-9eeb-11e8-8ccf-9f5546a8e54d.png)



위와 같이 재귀적으로 호출했을 때 아래와 같이 하위 문제들을 풀는 과정에서 수많은 중복 계산이 발생한다. 



fib(5)

fib(4) + fib(3)

( fib(3) + fib(2) ) + ( fib(2) + fib(1) )

( (fib(2) + fib(1) ) + ( fib(1) + fib(0) ) ) + ( ( fib(1) + fib(0) ) + fib(1) )

( (fib(1) + fib(0) + fib(1) ) + ( fib(1) + fib(0) ) ) + ( ( fib(1) + fib(0) ) + fib(1) )



위 예에서 fib(2)는 세 번 계산된다(하위 문제들의 중첩). 예에서는 fib(5)지만 만약 n이 매우 크다면 중복의 문제는 더욱 심각해진다. 이런 문제를 해겨라기 위해서 동일한 하위 문제를 다시 처리하는 것을 대신해 앞서 계산된 결과들을 어딘가에 저장해 다시 사용한다면 복잡도를 개선할 수 있다.



메모이제이션의 동작은 다음과 같다. 재귀함수로 시작하고 함수에 의해 계산된 결과와 함수 매개 변수 값을 매핑한 테이블에 추가한다. 그런 후 이 함수가 동일한 파라미터들로 다시 호출되면 간단하게 이 테이블에서 값을 찾는다.



**Bottom-Up** 방식으로 기존의 피보나치 수열을 개선하면 아래와 같다.

```
int fib[n];
int fibonacci(int n) {
	// base case 검사
    if(n == 0 || n == 1) return 1;
    fib[0] = 1;
    fib[1] = 1;
    for(int i = 2; i < n; i++) {
        fib[i] = fibonacci[i-1] + fibonacci[i-2];
    }
    return fib[n-1];
}
```

  

**Top-Down** 방식으로 기존의 피보나치 수열을 개성하면 아래와 같다.

```
int fib[n];
int fibonacci(int n) {
    if(n == 1) return 0;
    if(n == 2) return 1;
    if(fib[n] != 0) return fib[n];
    return fib[n] = finbonacci(n-1) + finbonacci(n-2);
}
```



###### Note. 모든 문제들에서 top-down, bottom-up 두 가지 모두의 해결책을 발견할 수 있는 것은 아니다.

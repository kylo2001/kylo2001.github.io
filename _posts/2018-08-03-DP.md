---
layout: post
title:  "DP"
date:   2018-08-13 11:57:00
categories: algorithm
tags: featured
image: /assets/article_images/2014-08-29-welcome-to-jekyll/desktop.JPG
comments: true

---



## DP (다이나믹 프로그래밍)



이 챕터에서는 분할 정복, 탐욕 방법 같은 다른 기술들을 사용하여 최적의 해결책을 찾지 못하는 문제들을 풀어 볼 것이다. 동적 계획법은 간단한 기술이지만 완전히 익히는 것은 어렵다. DP문제를 익힐 수 있는 쉬운 방법은 가능한 많은 문제들을 풀어보는 것이다. 



**동적 계획법의 전략?**

동적 계획법은 메모이제이션과 함께 동작한다. 분할 정복과 동적 계획법의 큰 차이점은 분할 정복은 하위 문제들이 독립적이지만 DP는 하위 문제들 간의 중첩이 일어납니다. 

동적 계획법은 많은 문제들에 대해 메모이제이션을 사용하여(이미 해결한 하위 문제들을 테이블에 보관한다.) 지수적 복잡도(O(2^n), O(3^n) 등 )를 다항적 복잡도(O(n^2), O(n^3) 등)로 줄입니다. DP의 핵심적인 구성 요소들은 다음과 같다.

* 재귀(Recursion) : 하위 문제들을 재귀적으로 처리한다.

* 메모이제이션(Memoization) : 이미 계산된 값들을 테이블에 저장한다(메모이제이션은 캐싱을 의미한다).

  동적 계획법(Dynamic Programming) = 재귀(Recursion) + 메모이제이션(Memoization)



**동적 계획법 전략의 특성**

동적 계획법의 아래와 같은 두 가지 특징으로 주어진 문제를 해결할 수 있는지 여부를 알 수 있다.

* 최적의 하부 구조(Optimal substructure) : 문제에 대한 최적의 해결방법은 하부 문제들에 대한 최적의 해결책을 포함한다.
* 하위 문제들의 중첩(Overlapping subproblems) : 문제에 대한 재귀적 해결 방법은 빈번하게 반복되는 적은 수의 서로 다른 하위 문제들을 가진다.



**동적 계획법으로 모든 문제를 풀 수 있을까?**

탐욕 기술, 분할 정복 기술과 동일하게 DP로 모든 문제를 풀 수는 없다. 어떤 알고리즘적 기술(탐욕, 분할 정복 그리고 동적 계획법)로도 풀리지 않는 문제들이 있다.

동적 계획법과 직접적인 재귀의 차이점은 재귀 호출의 메모이제이션이다. 만일 하위 문제들이 독립적이고 반복이 없다면 메모이제이션은 도움이 되지 않는다. 따라서 동적 계획법은 모든 문제들의 해결책이 아니다.



**동적 계획법 접근 방법들**

DP문제를 풀기 위해 기본적으로 아래 두 가지 접근법이 있다.

* Bottom-Up 동적 계획법
* Top-Down 동적 계획법



**Bottom-Up 동적 계획법**

문제에 대한 해법이 하위 문제들을 가지고 재귀적으로 공식화되면 문제를 bottom-up 방식으로 제공식화할 수 있다. 먼저 하위 문제들을 풀고 나서 이 해답들을 더 큰 하위 문제에 대한 해법을 조립하고 도출하기 위해 사용한다. 이 방법은 일반적으로 작은 하위 문제의 솔루션을 사용하여 점점 더 큰 상위 문제들의 해답을 반복적으로 만들어 표에 정리해 완성한다.



**Top-Down 동적 계획법**

이 방법은 문제의 재귀식에서 바로 도출된다. 문제의 해답이 하위 문제들의 해답을 재귀적으로 사용하여 표현하고 하위 문제들이 서로 중첩된다면 하위 문제들의 해답들을 한 번씩 테이블에 저장 혹은 메모이즈(Memoize)한다. 새로운 하위 문제들을 풀어야 할 때 먼저 테이블에 이미 같은 하위 문제의 해답이 있는지 확인한다. 존재하면 이미 계산된 값을 바로 사용하고 그렇지 않으면 해당 하위 문제의 해답을 테이블에 저장한다.



**Bottom-Up VS Top-Down 프로그래밍**

Bottom-Up 프로그래밍에서 프로그래머는 계산할 값들과 계산 순서를 생각해야 합니다. 이 경우 필요한 모든 하위 문제들은 먼저 해결되어 더 큰 하위 문제의 해결책을 구축하는데 사용된다.

Top-Down 프로그래밍에서 사용한 원래 코드의 재귀 구조는 유지되지만 불필요한 재계산을 피할 수 있다. 문제를 하위 문제로 분할한 후 이러한 하위 문제들을 풀고, 다시 풀어야 할 더 큰 하위 문제를 풀때 필요한 만큼 푼 결과들을 저장한다.



많은 사람들이 알고 있는 피보나치 수열을 예로 좀 더 이해를 해보자.



피보나치 수열이란 현재 수는 이전 두 수 의 합인 수를 말한다. 다음과 같이 정의된다.

```
fib(n) = 0, n = 0일때
       = 1, for n = 1 일때
       = fib(n - 1) + fib(n - 2). for n > 1일때
```



이를 재귀적으로 함수를 구현해보면 아래와 같다.

```
int recursiveFibonacci(int n) {
    if(n == 0) 
        return 0;
    if(n == 1)
    	return 1;
    return recursiveFibonacci(n - 1) + recursiveFibonacci(n - 2);
}
```

![](https://user-images.githubusercontent.com/20294786/44010184-e8d90104-9eeb-11e8-8ccf-9f5546a8e54d.png)



위와 같이 재귀적으로 호출했을 때 아래와 같이 하위 문제들을 풀는 과정에서 수많은 중복 계산이 발생한다. 



fib(5)

fib(4) + fib(3)

( fib(3) + fib(2) ) + ( fib(2) + fib(1) )

( (fib(2) + fib(1) ) + ( fib(1) + fib(0) ) ) + ( ( fib(1) + fib(0) ) + fib(1) )

( (fib(1) + fib(0) + fib(1) ) + ( fib(1) + fib(0) ) ) + ( ( fib(1) + fib(0) ) + fib(1) )



위 예에서 fib(2)는 세 번 계산된다(하위 문제들의 중첩). 예에서는 fib(5)지만 만약 n이 매우 크다면 중복의 문제는 더욱 심각해진다. 이런 문제를 해겨라기 위해서 동일한 하위 문제를 다시 처리하는 것을 대신해 앞서 계산된 결과들을 어딘가에 저장해 다시 사용한다면 복잡도를 개선할 수 있다.



메모이제이션의 동작은 다음과 같다. 재귀함수로 시작하고 함수에 의해 계산된 결과와 함수 매개 변수 값을 매핑한 테이블에 추가한다. 그런 후 이 함수가 동일한 파라미터들로 다시 호출되면 간단하게 이 테이블에서 값을 찾는다.



**Bottom-Up** 방식으로 기존의 피보나치 수열을 개선하면 아래와 같다.

```
int fib[n];
int fibonacci(int n) {
	// base case 검사
    if(n == 0 || n == 1) return 1;
    fib[0] = 1;
    fib[1] = 1;
    for(int i = 2; i < n; i++) {
        fib[i] = fibonacci[i-1] + fibonacci[i-2];
    }
    return fib[n-1];
}
```

  

**Top-Down** 방식으로 기존의 피보나치 수열을 개성하면 아래와 같다.

```
int fib[n];
int fibonacci(int n) {
    if(n == 1) return 0;
    if(n == 2) return 1;
    if(fib[n] != 0) return fib[n];
    return fib[n] = finbonacci(n-1) + finbonacci(n-2);
}
```



###### Note. 모든 문제들에서 top-down, bottom-up 두 가지 모두의 해결책을 발견할 수 있는 것은 아니다.



**붕어빵 판매하기(11052)**

이번 문제를 해결하기 위해서 그림을 그려보았다.

![](https://user-images.githubusercontent.com/20294786/43999683-6963e866-9e4c-11e8-9316-3d881ebcaf02.png)

문제는 이러하다.

도날드라는 붕어빵 장사꾼이 있다. n개의 붕어빵을 만들었고 한번에 i개를 팔았을 때 받을 수 있는 돈은 p[i]원이다. 문제에서 요구하는 답은 N개의 붕어빵을 팔았을 때 최대로 벌 수 있는 수익은 얼마인가?? 이다. 점화식을 위해 dp[n]을 이렇게 정의하겠다. 

```
p[i] 는 i 개의 붕어빵을 팔았을 때 받을 수 있는 이익
dp[n] = 붕어빵 n개를 팔았을 때 얻을 수 있는 최대 수익
```

dp배열은 Memoization을 위해 사용된다.

이 문제를 풀기 위해 생각해낸 로직은 아래와 같다.

만약 어떤 손님에게 i개의 붕어빵을 팔았다면 나머지 손님에게는 n - i개의 붕어빵을 팔아야 한다.

따라서 이 문제에 점화식을 도출해낸다면 아래와 같을 것이다.

```
dp[n] = p[i] + dp[n-i]
```

 

도출해낸 점화식을 가지고 디버깅을 해보았다.

![1](https://user-images.githubusercontent.com/20294786/43999682-6941da64-9e4c-11e8-9313-d313f19655fe.png)

C++ 구현 코드

```
#include <iostream>
#define MAX(a, b) a>b ? a : b
using namespace std;

int n, dp[1001], a[1001];

void in() {
    cin >> n;
    
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
}

void selling() {
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            dp[i] = MAX(dp[i], a[j] + dp[i-j]);
        }
    }
}

void out() {
    cout << dp[n] << endl;
}

int main(int argc, const char * argv[]) {
    in();
    selling();
    out();
    return 0;
}
```





**계단 오르기(2579)**

이번 문제는 제약이 있는 DP문제이다. 여기서 제약은

1. 연속으로 3칸을 올라갈 수 없다.
2. 마지막 계단에 반드시 올라가야 한다.
3. 한번에 1칸 또는 2칸을 올라갈 수 있다.

즉, 예제에서 칸수가 6인 계단의 점수가 10, 20, 15, 25, 10, 20으로 주어졌을 때, 10 -> 20 -> 15 -> 는 불가하며 마지막 20은 반드시 밟아야 된다는 것이다.

이런 제약이 주어진 문제들은 이 조건을 어떻게 하면 어기지 않으면서 식을 만들까를 고민해 봐야 한다. 대부분의 DP문제가 그러하듯이 뒤에서부터 고려하여 식을 짜는 것이 훨씬 편하다.



문제 에서 주어지는 계단을 살짝 변형하여 배열로 나타내면 아래와 같다.

![](https://user-images.githubusercontent.com/20294786/43999701-bec9a494-9e4c-11e8-883b-f7c84b4b38ac.png)



이 그림을 바탕으로 뒤에서부터 접근하여 조건들을 만족하는 식을 살펴보자.

먼저 맨 뒤 계단은 반드시 밟아야 된다. 따라서 맨 뒤 계단을 밟는 방법은 맨뒤 -1 계단에서 1칸 올라오는 경우, 맨뒤 -2번째 계단에서 2칸을 건너 올라오는 경우이다. 그 이전 경우들은 어떻게 하던 간에 결국 저 2가지 경우 중 하나에 속해지기 때문에 고려할 필요가 없다.



![](https://user-images.githubusercontent.com/20294786/43999700-bea46a3a-9e4c-11e8-8ea6-f4401f061536.png)



결국 이렇게 나오는 것이고, 이제 dp[i]를 정의해 주도록 한다. 우리가 구해야 할 것은 마지막 계단을 밟았을 때 얻을 수 있는 최대 점수이다. 따라서 dp[i] = i번째 계단에서 최대점수가 된다. 그렇다면 위 그림의 경우 dp[i] = (dp[i-2]와 dp[i-1]중 큰 값) + a[i]가 된다.



그런데 여기서 이렇게만 하면 "틀렸습니다."라는 결과를 받을 것이다. 그 이유는 바로 저런 경우 3칸 연속 오르는 경우를 배제할 수 없기 때문이다. 따라서 1차원 배열로만 생각했던 것을 2차원 배열로 확장해서 생각해보자.

```
(1) dp[i][0] = i번째 계단을 1칸 전에 올라와서 얻을 수 있는 최대 점수
(2) dp[i][1] = i번째 계단을 2칸 전에 올라와서 얻을 수 있는 최대 점수
```



이렇게 정했으면 다시 한번 생각해 보자. 어떻게 3칸 연속 올라오는 것을 방지할 수 있을까?

우선 (1)의 경우엔 이미 2칸을 올라왔기 때문에 다음 계단이 3연속 되는 계단인지 생각해줄 필요가 없다. 오히려 임시 계단(마지막 -2 계단)에 서있을 때, 여기까지 오는데 2칸 전에서 올라오는 경우와 1칸 전에서 올라오는 경우 중 어느 값이 큰 값인지를 고려해 줘야 한다. 그림으로 보면 아래와 같아.

![](https://user-images.githubusercontent.com/20294786/43999699-be7f7f86-9e4c-11e8-998f-ae6cc94abfe8.png)



따라서 (2)의 경우 점화식은 다음과 같다.

```
// i번째 계단을 2칸 전에 올라와서 얻을 수 있는 최대 점수
dp[i][1] = MAX(dp[i-2][0], dp[i-2][1]) + a[i];
```



반면, (1)의 경우 이미 현재 계단에 1칸을 올라왔기 때문에 3연속 올라가는 경우를 방지해주어야한다. dp[i]의 최대값을 비교하는 과정에서 애초에 dp[i-1] 번째 칸(현재 계단 -1)에 두 칸을 올라온 경우만 고려해주면 된다. 따라서 (1)의 점화식은 아래와 같다.

```
// i번째 계단을 1칸 전에 올라와서 얻을 수 있는 최대 점수
dp[i][0] = dp[i-1][1] + a[i];
```

 

자 이제 생각해낸 점화식을 디버깅 해보자.

![](https://user-images.githubusercontent.com/20294786/43999698-be59c0b6-9e4c-11e8-8f02-63038ce9d99e.png)

C++ 구현 코드

```
#include <iostream>
#define MAX(a, b) a>b ? a : b
using namespace std;
 
int n, a[301], dp[301][2];

void in() {
    cin >> n;

    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
}

void climbing() {
    dp[1][0] = dp[1][1] = a[1];

    for(int i = 2; i <= n; i++) {
        dp[i][0] = dp[i - 1][1] + a[i];

        int maxValue = MAX(dp[i - 2][0], dp[i - 2][1]);
        int stairValue = a[i];

        dp[i][1] = maxValue + stairValue;
    }
}

void out() {
    int result = MAX(dp[n][0], dp[n][1]);
    cout << result << endl;
}

int main(int argc, const char * argv[]) {
    in();
    climbing();
    out();
    return 0;
}
```

참고 블로그 : https://m.blog.naver.com/PostView.nhn?blogId=occidere&logNo=220788947949&proxyReferer=https%3A%2F%2Fwww.google.com%2F

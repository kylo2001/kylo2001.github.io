---
layout: post
title:  "DFS"
date:   2018-08-03 18:07:00
categories: algorithm
tags: featured
image: /assets/article_images/2014-08-29-welcome-to-jekyll/desktop.JPG
comments: true
---


### **알고리즘 2주차 스터디 정리**



**1. DFS 정의**

깊이우선탐색이란 그래프를 탐색하는 알고리즘 중 하나의 종류이다.특정 노드를 출발하여 깊게 들어 갈 수 있을 때까지 들어가고 들어 갈 곳이 없다면 다시 나오는 알고리즘이다. FILO,  LIFO 라는 특성을 가지고 있기에 DFS 알고리즘을 구현할때는 보통 스택 또는 재귀 호출 방법을 사용한다.



**2. DFS 특징**

- **장점 :**

  - 단지 현 경로상의 노드들만을 기억하면 되므로 저장 공간의 수요가 비교적 적다.
  - 목표 노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.

- ##### 단점 :

  - 해가 없는 경로에 깊이 빠질 가능성이 있다. 따라서 실제로는 미리 지정한 임의 깊이까지만 탐색하고 목표 노드를 발견하지 못하면 다음 경로를 따라 탐색하는 방법이 유용할 수 있다.
  - 얻어진 해가 최단 경로가 된다면 보장이 없다. 이는 목표에 이르는 경로가 다수인 문제에 대해 DFS는 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다는 의미이다.**



**3. DFS 기타**  

![dfs1](/Users/kimdonghwan/kylo2001/assets/article_images/2018-08-03-DFS/dfs1.png)



##### DFS 탐색 순서

![dfs2](/Users/kimdonghwan/kylo2001/assets/article_images/2018-08-03-DFS/dfs2.png)



![dfs3](/Users/kimdonghwan/kylo2001/assets/article_images/2018-08-03-DFS/dfs3.png)



**4. 백준 코드 및 주석**

1260 DFS와 BFS

```
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

int n; // 정점 (1 ≤ N ≤ 1,000)
int m; // 간선 (1 ≤ M ≤ 10,000)
int startVertex; // 출발 정점 start vertex

int matrix[1001][1001]; // 인접 행렬
bool check[1001];       // 정점 방문 확인 배열

void in() {
    scanf("%d %d %d", &n, &m, &startVertex);
    int vertex1, vertex2;

    for(int i = 0; i < m; i++) {
        cin >> vertex1 >> vertex2;
        matrix[vertex1][vertex2] = 1;
        matrix[vertex2][vertex1] = 1;
    }
}

void travelDFS(int vertex) {
    cout << vertex;
    check[vertex] = true;
    for(int i = 1; i <= n; i++) {
        // 0 ~ n+1를 순차적으로 확인하여 간선이 존재하고, 방문할 정점이 방문된적 없다면 해당 정점을 방문한다.
        if(matrix[vertex][i] == 1 && check[i] == false) {
            cout << " ";
            travelDFS(i);
        }
    }
}

void travelBFS(int vertex) {
    int currentVertex;
    queue<int> q;
    q.push(vertex);
    check[vertex] = true;
    
    while(!q.empty()) {
        currentVertex = q.front();
        cout << currentVertex;
        q.pop();
        cout << " ";
        
        for(int i = 1; i <= n; i++) {
            if(matrix[currentVertex][i] == 1 && check[i] == false) {
                q.push(i);
                check[i] = true;
            }
        }
    }
}
void init() {
    for(int i = 1; i <= n; i++) {
        check[i] = false;
    }
    cout << endl;
}

int main(int argc, const char * argv[]) {
    in();
    travelDFS(startVertex);
    init();
    travelBFS(startVertex);
    return 0;
}
```



2667 단지번호 붙이기

```
#include <cstring>
#include <iostream>
#include <algorithm> // sort함수를 위해 포함시켰다.
using namespace std;
// (5 <= n <= 25)
// 홀수 : N^2/2 + 1 / 짝수 : N^2/2, N의 최대 값이 25이므로 따라서 313를 최대로 생각하고 최대 단지수에 맞춰 배열들을 선언한다.

int foundedComplexNumber;
int complexes[313];
int apartments[25][25];
bool check[25][25];

int direction[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; // 남, 북, 동, 서
int n; // 지도의 크기

void in() {
    scanf("%d", &n);
    
    // apartments[n][n] 크기의 2차원 배열을 생성한다.
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            int b;
            scanf("%1d", &b);
            if(b == 1){
                apartments[i][j] = 1;
            }
        }
    }
    
//    for(int i = 0; i < n; i++) {
//        for(int j = 0; j < n; j++) {
//            cout << apartments[i][j];
//        }
//        cout << endl;
//    }
}

// 움직일 수 있는 좌표가 주어진 배열내부에 존재하는가를 검사하기 위한 메소드
bool isInside(int x, int y) {
    return (x >= 0 && x < n) && (y >= 0 && y < n);
}

void search(int x, int y) {
    int currentX = x, currentY = y;
    
    check[currentX][currentY] = true;
    complexes[foundedComplexNumber]++;
    
    for(int i=0; i<4; i++){
        int nextX = currentX + direction[i][0];
        int nextY = currentY + direction[i][1];
        
        // next y, x가 배열 내부에 있고, 방문한 적이 없고, map에 true로 되어있으면
        if(isInside(nextX, nextY) && check[nextX][nextY] == false && apartments[nextX][nextY] == 1){
            search(nextX, nextY);
        }
    }
}

int foundComplexNumber() {
    int complexNumber = 0;
    for(int i = 0; i < 313; i++) {
        if(complexes[i] == 0) {
            break;
        } else {
            complexNumber++;
        }
    }
    return complexNumber;
}

void numbering() {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++){
            if(apartments[i][j] == 1 && check[i][j] == false) {
                foundedComplexNumber = foundComplexNumber();
                search(i, j);
            }
        }
    }
}

void sortComplexes() {
    sort(complexes, complexes + foundedComplexNumber);
}

void out() {
    if (complexes[foundedComplexNumber] != 0) {
        // 0단지, 1단지, 2단지 .... 하기 때문에 +1이 필요하다.
        foundedComplexNumber++;
        sortComplexes();
        cout << foundedComplexNumber << "\n";
        
        for(int i = 0; i < foundedComplexNumber; i++) {
            cout << complexes[i] << endl;
        }
    }
}

int main(int argc, const char * argv[]) {
    in();
    numbering();
    out();
    return 0;
}
```



1012 유기농 배추

```
#include <iostream>
using namespace std;

int testCaseNumber;
int cabbageNumber;
int earthwormNumber = 0;
int n, m; // (n, m)    1<= n, m <= 50

int cabbageField[50][50];
bool check[50][50];

int direction[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

void in() {
    cin >> m >> n >> cabbageNumber;
    int x, y; // 임시로 행렬을 만들기 위한 변수
    
    for(int i = 0; i < cabbageNumber; i++) {
        cin >> y >> x;
        cabbageField[x][y] = 1;
    }
}

bool isInside(int x, int y) {
    return (x >= 0 && x < n) && (y >= 0 && y < m);
}

void search(int x, int y) {
    int currentX = x, currentY = y;
    
    check[currentX][currentY] = true;
    for(int i = 0; i < 4; i++) {
        int nextX = currentX + direction[i][0];
        int nextY = currentY + direction[i][1];
        
        if(isInside(nextX, nextY) && check[nextX][nextY] == false && cabbageField[nextX][nextY] == 1) {
            search(nextX, nextY);
        }
    }
}

void numbering() {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(cabbageField[i][j] == 1 && check[i][j] == false) {
                earthwormNumber++;
                search(i, j);
            }
        }
    }
}
void out() {
    cout << earthwormNumber << endl;
}

void init() {
    earthwormNumber = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            cabbageField[i][j] = 0;
            check[i][j] = false;
        }
    }
}

int main(int argc, const char * argv[]) {
    cin >> testCaseNumber;
    for(int i = 0; i < testCaseNumber; i++) {
        in();
        numbering();
        out();
        init();
    }
    return 0;
}
```
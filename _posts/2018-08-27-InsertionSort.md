---
layout: post
title:  "삽입 정렬"
date:   2018-08-27 2:40:00
categories: algorithm
tags: featured
image: /assets/article_images/2014-08-29-welcome-to-jekyll/desktop.JPG
comments: true
---



## 삽입 정렬(Insertion sort)

삽입 정렬은 간단하면서도 효과적인 비교 정렬법입니다. 이 알고리즘은 매 반복마다 뒤쪽의 정렬되지 않은 요소들의 목록에서 요소를 삭제하고 삭제한 요소를 앞쪽에의 이미 정렬된 목록 내 알맞은 자리에 삽입합니다. 입력 데이터에서 삭제될 요소는 정렬되지 않은 목록에서 무작위로 선택하고(일반적으로 앞에서 차례로 선택합니다.) 입력 데이터 내 모든 요소를 처리할 때까지 반복합니다.



##### 장점

* 간단합니다.
* 적은 데이터 양에 효과적이다.
* 적용성 : 입력 목록이 완전하지는 않더라도 사전 정렬이 되어있다면 삽입 정렬은 d가 도치 횟수일 때 O(n + d)의 복잡도를 가집니다.
* 실제로 선택 정렬과 삽입 정렬은 최악의 복잡도가 O(n^2)인 다른 모든 알고리즘보다 효과적이지는 않습니다.
* 안정성 : 키가 동일한 경우 입력 데이터의 순서가 보존됩니다. 
* 제자리 정렬 : 추가적인 고정적인 메모리 공간으로 O(1)만을 소요합니다.
* 온라인 : 입력 인자로 받은 목록을 정렬합니다.



##### 알고리즘

삽입 정렬은 매 반복마다 정렬되지 않은 목록에서 하나의 요소를 선택(일반적으로 배열의 앞부터 차례대로 선택)하여 선택한 요소를 삭제하고 삭제한 요소를 앞 쪽의 정렬된 목록 부분과 비교하여 정렬된 목록 내 알맞은 자리에 삽입하는 절차를 배열의 모든 요소에 대해 수행합니다. 일반적으로 제자리 정렬을 수행합니다. 



![](https://user-images.githubusercontent.com/20294786/44631395-db600080-a9a5-11e8-8268-5f2726505f9e.jpeg)



![](https://user-images.githubusercontent.com/20294786/44631396-dc912d80-a9a5-11e8-9860-6040a84396e0.jpeg)



##### 분석

* 최악의 경우 분석

최악의 경우는 매 반복(i번째)에서 이미 정렬된 모든 요소들(A[1]...A[i-1])을 모두 이동시켜야 할 경우에 발생합니다. 이 경우는 A[i]요소의 키가 앞의 다른 모든 요소보다 작을 때 발생합니다. 이 경우 복잡도는 Θ(i-1) 입니다.

```
T(n) = Θ(1) + Θ(2) + Θ(3) + ... + Θ(n-1) 

		= Θ(1 + 2 + 3 + ... + n-1) = Θ(n(n-1) / 2) ≈ Θ(n^2)
```



* 평균적인 경우 분석

일반적으로 평균은 매 반복마다 A[i]는 A[1] ... A[i-1]의 중간에 삽입된다고 볼 수 있습니다.  이 경우 복잡도는 Θ(i/2) 입니다.

```
T(n) = ∑Θ(n/2)(1 <= i <= n) ≈ Θ(n^2)
```



##### 성능

- 최악의 경우 복잡도 : O(n^2)
- 최선의 경우 복잡도 : O(n^2)
- 평균 복잡도 : O(n^2)
- 최악의 경우  공간 복잡도 : 보조 공간 O(1), 전체 O(n^2)



##### 다른 정렬 알고리즘과의 비교

삽입 정렬은 최악의 경우 O(n^2)의 복잡도를 가지는 기본적인 정렬 알고리즘입니다. 삽입 정렬은 (삽입 정렬이 가진 적용성 때문에) 미리 데이터가 어느 정도 정렬이 되어 있는 상태거나 입력 데이터의 양이 적을때 사용됩니다. 이러한 이유와 안정성 때문에 삽입 정렬은 병합 정렬(merge sort) 또는 퀵 정렬(quick sort) 같은 높은 오버헤드를 분할 정복하는 정렬 알고리즘에서 재귀적으로 사용됩니다.



> * 버블 정렬은 최악의 경우와 평균적인 경우 모두 n^2/2의 반복과 n^2/2 치환을 수행합니다.
> * 선택 정렬은 n^2/2번의 비교와 n번의 치환이 일어납니다.
> * 삽입 정렬은 평균적인 경우 n^2/4번의 비교와 n^2/8번의 치환이 일어나며 최악의 경우는 그 두 배가 됩니다.
> * 삽입 정렬은 부분 정렬의 정도에 따른 근사선형을 가집니다.
> * 선택 정렬이 제일 좋은 경우는 키는 작고 값들이 큰 요소를 가진 목록을 정렬할 경우입니다.



##### 순서도

![](https://user-images.githubusercontent.com/20294786/44631742-61cb1100-a9ab-11e8-92a7-520998aa6e93.jpeg)



##### C++ 구현 코드

```
#include <iostream>
using namespace std;

int arr[10] = {30, 20, 10, 50, 40, 60, 100, 80, 90, 70};
int n = sizeof(arr) / sizeof(int);

void swap(int *x, int *y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

void insertionSort() {
    for (int i = 1 ; i < n; i++) {
        for (int j = i-1; j >= 0; j--) {
            if (arr[j] > arr[i]) {
                swap(&arr[i], &arr[j]);
                i = j;
            }
        }
    }
}

void out() {
    for (int i = 0; i < n; i++) { cout << arr[i] << " "; }
    cout << endl;
}

int main(int argc, const char * argv[]) {
    insertionSort();
    out();
    return 0;
}
```